<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>清风竹影</title>
    <link>https://liudx1985.gitee.io/</link>
    <description>Recent content on 清风竹影</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Mar 2024 09:11:03 +0800</lastBuildDate><atom:link href="https://liudx1985.gitee.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Andriod开发从入门到放弃</title>
      <link>https://liudx1985.gitee.io/post/andriod/</link>
      <pubDate>Wed, 06 Mar 2024 09:11:03 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/andriod/</guid>
      <description>1 安装  安装android-studio,如android-studio-2020.3.1.26-windows.exe 1 安装SDK！建议找比较完整的SDK目录压缩包下载 第一步不装avd（andriod模拟器)，下载雷电模拟器来替代 下载必要的依赖库okhttp-3.8.1.jar\okio-1.14.0.jar等（吐槽下JAVA这个服务器开发语言，居然没有好用的HTTP封装类，和C++没有标准的网络库一样，属实难崩） *安装postman等工具用于测试  2 配置  首先配置SDK目录：   配置gradle（大坑一个，参考2）
  step-1：修改hosts文件，附加：
# dl.google.com fucking andriod 58.254.149.225 dl.google.com 220.181.174.97 dl.google.com 180.163.151.161 dl.google.com 220.181.174.33 dl.google.com 58.254.137.161 dl.google.com 203.208.39.193 dl.google.com   step-2:创建 C:\Users\Liudx1985\.gradle\init.gradle
allprojects{  repositories {  def ALIYUN_REPOSITORY_URL = &amp;#39;https://maven.aliyun.com/repository/public&amp;#39;  def ALIYUN_JCENTER_URL = &amp;#39;https://maven.aliyun.com/repository/public&amp;#39;  def ALIYUN_GOOGLE_URL = &amp;#39;https://maven.aliyun.com/repository/google&amp;#39;  def ALIYUN_GRADLE_PLUGIN_URL = &amp;#39;https://maven.aliyun.com/repository/gradle-plugin&amp;#39;  all { ArtifactRepository repo -&amp;gt;  if(repo instanceof MavenArtifactRepository){  def url = repo.</description>
    </item>
    
    <item>
      <title>electron-vite-vue开发指北</title>
      <link>https://liudx1985.gitee.io/post/electron/</link>
      <pubDate>Sun, 04 Feb 2024 11:30:40 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/electron/</guid>
      <description>1. 准备nodejs环境   set up nvm via Releases · coreybutler/nvm-windows (github.com)
  config mirror
#设置npm_mirror: nvm npm_mirror https://npmmirror.com/mirrors/npm/ #设置node_mirror: nvm node_mirror https://npmmirror.com/mirrors/node/   install nodejs @Previous Releases | Node.js (nodejs.org)
nvm uninstall 10.13.0 # 删掉低版本的 10.13.0 nvm list available# check nodejs available @ nvm install 14.21.3 # version 16.XX nvm install lts #最新的 LTS 版本 nvm install latest # 安装最新版本的 Node.js，也就是 Current 版本：   use nodejs</description>
    </item>
    
    <item>
      <title>Vue3高阶组件技术</title>
      <link>https://liudx1985.gitee.io/post/vue3/</link>
      <pubDate>Fri, 05 Jan 2024 15:37:17 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/vue3/</guid>
      <description>1.Props | Vue.js (vuejs.org) ​	父组件需要向子组件注入数据，可以使用props，类似于attrs:&amp;lt;comp label=&amp;quot;xxxx&amp;quot;&amp;gt;
 特别注意！
  props是单向从父到子数据流，如果是子组件修改父组件属性，需要用#3 event
  props在子组件是只读的，意味我们无法修改props！
   &amp;lt;script setup&amp;gt;  const props = defineProps([&amp;#39;foo&amp;#39;]) console.log(props.foo)  const props2 = defineProps({  label: {  type: String,  require: true,  },  name: {  type: String,  require: true,  }  }) &amp;lt;/script&amp;gt; 通常prop的玩法是： 1，通过父组件直接修改props绑定的变量，子组件内props自动更新界面！2、初始化给内部的原生组件，然后在原生组件事件里把prop值更新回去，所谓的v-model模式。
PS,如果我们要强行额外写入属性怎么办呢，可以利用provide\inject跨层级传输接口依赖注入 | Vue.js (vuejs.org)！:
provide(&amp;#39;currentTab&amp;#39;, currentTab) # 父组件写变量 inject(&amp;#34;currentTab&amp;#34;) # 子组件注入变量，注意，这个变量是Ref，并不位于props! 2.</description>
    </item>
    
    <item>
      <title>利用Tesseract对图片或pdf进行OCR</title>
      <link>https://liudx1985.gitee.io/post/tesseractocr/</link>
      <pubDate>Sat, 21 Oct 2023 08:48:55 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/tesseractocr/</guid>
      <description>1. 准备  下载OCR核心工具包Tesseract并安装，参考Tesseract OCR 下载及安装教程 （中英文语言包）_eng.traineddata下载-CSDN博客，注意中文语言包需要下载，如果不下载语言包，可能无法识别中文。 下载PDF转图片工具包Releases · oschwartz10612/poppler-windows (github.com);如果仅仅是OCR图片，可以不用下载这个 完成后，将上述两个的（tesseract.exe&amp;amp;pdfimages.exe）目录加入到电脑的环境变量PATH中：  2 安装python 依赖 下面安装Python 的依赖
pip install pytesseract pip install pdf2image 3 识别图片 def ocr_image():  from PIL import Image  # 打开图片  image = Image.open(&amp;#39;demo.png&amp;#39;)  # 使用pytesseract进行OCR识别  text = pytesseract.image_to_string(image, lang=&amp;#39;chi_sim&amp;#39;) # lang设置为中文  # 输出识别结果  print(text) 4 识别pdf def ocr_pdf(pdf):  from pdf2image import convert_from_path  # 设置tesseract.exe的路径  pytesseract.pytesseract.tesseract_cmd = r&amp;#39;D:\Games\TesseractOCR5\tesseract.</description>
    </item>
    
    <item>
      <title>JavaScript 模块：CommonJS VS Es6</title>
      <link>https://liudx1985.gitee.io/post/js_module/</link>
      <pubDate>Wed, 20 Sep 2023 19:10:36 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/js_module/</guid>
      <description>[TOC]
JavaScript 模块有两种：CommonJS和ES6模块化规范12：
1. CommonJS 模块规范 node.js的默认方式，使用exports(aka. global.module.exports) 对象导出，使用require 函数导入，下面是一个简单的示例（上面是模块，下面是调用）：
// circle.js const PI = 3.1415 function area(r) {  return PI * r * r } // exports exports.PI = PI exports.area = area // 也可以写成下面的方式： exports.PI = 3.14;exports.area=(r)=&amp;gt; PI * r * r // 或者：exports = {PI, area} // main.js const circle = require(&amp;#34;./circle.js&amp;#34;)// 就是上面模块的exports对象。 console.log(circle.PI) console.log(circle.area(5))  // 或者，结合对象解构赋值写成 const {area,PI} = require(&amp;#39;./circle&amp;#39;) // 可省略.js console.log(PI) console.log(area(5)) 2 ES6模块规范 ​	ES6新增export、import 关键字用于支持模块化。注意前后台都可以使用ES6模块，有一些细微的不同。</description>
    </item>
    
    <item>
      <title>Javascript迭代器、生成器、异步</title>
      <link>https://liudx1985.gitee.io/post/js_generator/</link>
      <pubDate>Wed, 26 Jul 2023 16:42:51 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/js_generator/</guid>
      <description>1 Javascript 迭代器 ES6 新增了一个新玩具iterator:迭代器iterator协议1主要规定了可迭代协议允许 JavaScript 对象定义或定制它们的迭代行为，例如，在一个 for..of 结构中，哪些值可以被遍历到。一些内置类型同时是内置的可迭代对象，并且有默认的迭代行为，比如 Array 或者 Map，而其他内置类型则不是（比如 Object）。下面是一个简单的fibonacci迭代器，可以无限生产一个数列1,1,2,3,5,8....
/** * @description function *迭代器对象 * @returns a fibonacci iterable object */ const fib = {  [Symbol.iterator]() {  let n1 = 1, n2 = 1  return {  // 使迭代器编程iterable  [Symbol.iterator]() { return this; },  next() {  let c = n2;  n2 = n1  n1 = n1 + c  return { value: c, done: false };  },  return(v) {  console.</description>
    </item>
    
    <item>
      <title>PySide6界面程序编写及打包</title>
      <link>https://liudx1985.gitee.io/post/pygui/</link>
      <pubDate>Wed, 12 Jul 2023 12:20:53 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/pygui/</guid>
      <description>1. setup  安装Pyside6,建议使用tsinghua源anaconda | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror  # 创建env conda create --name gui # 激活env conda active gui # 安装PySide6框架~ pip install --upgrade pip pip install pyqt6-tools # 安装UI 设计工具，for QTDesigner, PyUIC pip install pyside6 # +打包工具+ pip install pyinstaller auto-py-to-exe   设置pyCharm解释器
​	参考1 配置external Tools，在菜单中方便使用：目录类似:
  C:\Users\37556\anaconda3\envs\gui\Lib\site-packages\PySide6\designer.exe
  C:\Users\37556\anaconda3\envs\gui\Scripts\auto-py-to-exe.exe
    2 编写代码 2.1 打开QtDesigner,设计界面： ​ 运行工具QtDesinger，设计一个界面led.</description>
    </item>
    
    <item>
      <title>Argsort 以及Rank的Javascript代码练习</title>
      <link>https://liudx1985.gitee.io/post/argsort/</link>
      <pubDate>Tue, 23 May 2023 17:27:31 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/argsort/</guid>
      <description>1 引言：argsort以及rank排序问题 $\P$ argsort-定义
假设一个数组$a$由$$\underbrace{[x_0,x_1,\dots,x_i, \dots,x_n]}_{0\dots n乱序}$$构成,那么$b=argsort(a)$定义为：经过排序后a中元素（即$0..n$）的索引数组：
$$ \underbrace{[a中第0大数的索引,\dots,a中第i大数的索引, \dots,a中第n大数的索引]}_{0\dots n} $$
我们假设$a[i]= x$,由于$i是a中第x大的数$，那么$i在b中位置就是x$,${b[x]=i}$,如图所示：
消去x,可得: $$ b[x]=b[a[i]]=i $$
$\S$如果对a进行两次argsort，会发生神魔事情呢,这里由一个文章回答为什么对数列使用两次argsort后能得到原数列的rank数列？ - 知乎 (zhihu.com)，摘抄如下:
 对于一个从0~k-1组成序列a来说，执行argsort得到序列b就是b[a[i]]=i，再执行一次得到c就是c[b[j]]=j，代入j=a[i]得c[b[a[i]]]=a[i]，c[i]=a[i],所以一个rank序列两次argsort之后自然会变回原样
 结合上面的假设a是一个0&amp;hellip;n 乱序而来的数组，那么a里面存储的正好是数组a中各元素的排名。推广到任意乱序的序列S，我们只需要将S里的元素一一映射到$[(S_i,a_i)],a_i\in {0..n}$，然后对$S_i$排序,$argsort.argsort(a)=rank(a)$。
2. Show me the code! // a[i],b[i] = &amp;gt; {...a[i]:b[i]...} zip = function (a, b) {  let r = []  for (let i in a) {  r.push([a[i], b[i]])  }  return r; } // argsort返回的是索引 r，[a[r[0]]..a[r[n]]] 就是将a排序好的数组 function argsort(arr, cmp = (a, b) =&amp;gt; a - b) {  let arr_ind = zip(arr, range(arr.</description>
    </item>
    
    <item>
      <title>CSS3动画入门</title>
      <link>https://liudx1985.gitee.io/post/css_animate/</link>
      <pubDate>Tue, 18 Apr 2023 10:12:04 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/css_animate/</guid>
      <description>1 CSS 3 动画简介 ​	我们平时看到的动画是由一张一张静态的画面拼接而成的，我们通常用帧数来体现出动画效果的好与坏。 每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象。 高的帧率可以得到更流畅、更逼真的动画。1
​	​	css中实现动画有两种方式：过渡动画transitions|自定义动画animation;两者均可以通过元素的旋转(rotate)，缩放(scale)，倾斜（skew)或平移translate（*也可使用较复杂的矩阵API：(transform)）、颜色(color|background)、透明度(opcaticy)完成帧动画效果。下列示例是一个旋转的实例，可查阅MDN文档学习其他位置变换属性、颜色背景等。
&amp;lt;html&amp;gt;  &amp;lt;head&amp;gt;  &amp;lt;style&amp;gt;  #arrow-right{  display: inline-block; /*修改未行内元素、可修改高&amp;amp;宽*/  margin:4px;  width: 10px;  height: 10px;  border-right:2px solid black;  border-bottom:2px solid black;  transform-origin: 0% 100%; /*中心*/  transform: rotate(-45deg); /*然后逆时针旋转45°*/  }   #arrow-left{  display: inline-block;  margin:4px;  width: 10px;  height: 10px;  border-top:2px solid black;  border-left:2px solid black;  transform: rotate(-45deg); /*原地逆时针旋转45°*/  }  .</description>
    </item>
    
    <item>
      <title>Mysql绿色安装方法</title>
      <link>https://liudx1985.gitee.io/post/mysql/</link>
      <pubDate>Tue, 01 Nov 2022 10:18:52 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/mysql/</guid>
      <description>1. install   下载MySQLXX.zip, visitMySQL :: Download MySQL Community Server
For further information on MySQL or additional documentation, visit http://dev.mysql.com/doc/
  添加 MYSQL/bin到环境变量
  在mysql根目录增加my.ini如下：
[mysqld] #设置3306端口号 port=3306 #设置MySQL的安装目录 basedir=D:\Games\mysql-8.0.31 #设置MySQL数据库的数据存放目录 datadir=D:\Games\mysql-8.0.31\data #运行最大连接数 max_connections=200 #运行连接失败的次数。这也是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 #服务端使用的字符集默认为utf-8 character-set-server=utf8 [mysql] #客户端使用的字符集默认为utf8 default-character-set=utf8 [client] #客户端默认端口号为3306 port=3306   以管理员身份打开命令行!,进入mysql/bin目录 执行
# 安装服务 mysqld -remove MySQL mysqld --install mysql57 # 初始化data；这里，初始化会产生一个随机密码后面初次登录会使用！YD;W2Q9Tj,bs mysqld --initialize --console # 如果报错，试试这个 mysqld --initialize-insecure --console   开启mysql的服务net start mysql57</description>
    </item>
    
    <item>
      <title>RIP-GREP 工具使用</title>
      <link>https://liudx1985.gitee.io/post/rg/</link>
      <pubDate>Wed, 20 Jul 2022 11:55:43 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/rg/</guid>
      <description>1. 基本用法 rg &amp;#34;text&amp;#34; # 大小写敏感 rg -s &amp;#34;Word&amp;#34; # 大小写不敏感 rg -i &amp;#34;Word&amp;#34; 2. 搜索特定文件类型 rg -g &amp;#34;*.py&amp;#34; &amp;#34;text&amp;#34; rg -g &amp;#34;*.{md,html}&amp;#34; &amp;#34;mysql&amp;#34; 3.支持的类型,使用-t 搜索特定的文件类型 rg --type-list rg -t py &amp;#34;test&amp;#34; 4 搜索层次 rg &amp;#34;main&amp;#34; --max-depth=1 5 正则表达式内容 # 使用 -e REGEX 来指定正则表达式,如匹配数字 rg -e &amp;#34;\d+\.\d+&amp;#34; -C2 </description>
    </item>
    
    <item>
      <title>express 使用ajax</title>
      <link>https://liudx1985.gitee.io/post/ajax/</link>
      <pubDate>Fri, 22 Apr 2022 16:01:22 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/ajax/</guid>
      <description>1. 使用XMLHttpRequest 后台代码：
const express = require(&amp;#39;express&amp;#39;) const app = express() app.use(express.static(&amp;#34;public&amp;#34;)) // 静态资源目录 // FOR:&amp;#34;Content-type&amp;#34;:&amp;#34;application/x-www-form-urlencoded&amp;#34; app.use(express.urlencoded({extended: false })); // FOR:&amp;#34;Content-type&amp;#34;:&amp;#34;application/json&amp;#34; // app.use(express.json()) app.post(&amp;#39;/calc&amp;#39;, (req, res) =&amp;gt; { 	console.log(req.body) // MUST ADD app.use(...) 	setTimeout(()=&amp;gt;res.send(`&amp;lt;div style=&amp;#34;background-color:tomato; border-radius:50%;width:${req.body.w}px;height:${req.body.h}px&amp;#34;/&amp;gt;`), 1000) }) app.listen(8080) 在public/index.html里面可以搞一个按钮来发送ajax请求（可以使用JQUERY）:
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;	&amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 	&amp;lt;form action=&amp;#34;post&amp;#34;&amp;gt; 	&amp;lt;div&amp;gt;宽:&amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;w&amp;#34; placeholder=&amp;#34;input width&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 	&amp;lt;div&amp;gt;高:&amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;h&amp;#34; placeholder=&amp;#34;input height&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 	&amp;lt;div&amp;gt;&amp;lt;input type=&amp;#34;button&amp;#34; id=&amp;#34;calc&amp;#34; onclick=&amp;#34;Calc()&amp;#34; value=&amp;#34;calc&amp;#34; /&amp;gt;&amp;lt;/div&amp;gt; 	&amp;lt;/form&amp;gt;  &amp;lt;div id=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; 	function Calc() { 	let xhr = new XMLHttpRequest() // 创建XHR 	let w = parseFloat(document.</description>
    </item>
    
    <item>
      <title>Express 框架开发web服务器</title>
      <link>https://liudx1985.gitee.io/post/express/</link>
      <pubDate>Thu, 07 Apr 2022 14:13:35 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/express/</guid>
      <description>1. 最简单版本 var express = require(&amp;#39;express&amp;#39;); var app = express(); app.get(&amp;#39;/&amp;#39;, (req, res, next) =&amp;gt; {  res.send(&amp;#34;welcome to express&amp;#34;) })  var server = app.listen(8080) 启动后打开 http://localhost:8080
2 中间件  Express 使用get/post/use(path,callback)中间件;第一个参数为路由，第二个参数为处理中的 callback既可以是router对象又可以是函数
   2.1 将app.use第一个参数不设置，即可处理所有的消息：
 // 这里就是常用的网站维护，一般放在代码顶部。  app.use((req, res, next) =&amp;gt; {  if (webStop) res.send(&amp;#34;维护中&amp;#34;)  else next()  })   2.2 匹配404代码一般放在尾部,同样使用全部匹配。
app.use((req, res, next) =&amp;gt; {  res.send(&amp;#34;404 - 页面不存在&amp;#34;) // 页面不存在了 })   2.</description>
    </item>
    
    <item>
      <title>Node.js HTTP服务器</title>
      <link>https://liudx1985.gitee.io/post/nodejs_http/</link>
      <pubDate>Tue, 29 Mar 2022 15:08:14 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/nodejs_http/</guid>
      <description>1. 最简单版本GET/POST/&amp;hellip; const http = require(&amp;#39;http&amp;#39;) const hostname=&amp;#39;localhost&amp;#39; //`127.0.0.1` const port = 3000 const server = http.createServer((req, res) =&amp;gt; {  if (req.method==&amp;#39;GET&amp;#39;){//处理POST请求  res.statusCode = 200  res.setHeader(&amp;#39;Content-Type&amp;#39;, &amp;#39;text/plain&amp;#39;)  res.end(&amp;#39;你好世界\n&amp;#39;)  }  else if (req.method==&amp;#39;POST&amp;#39;){//处理POST请求  ...  } }) server.listen(port, () =&amp;gt; {  console.log(`服务器运行在 http://${hostname}:${port}/`) })  客户端地址 http://localhost:3000  2. 处理HTTP GET请求参数 ​	对于https://cn.bing.com/search?q=baidu&amp;amp;cvid=9ad 这种URL，可从中拆分出pathname、querystring。
 pathname: /search querystring : ?q=baidu&amp;amp;cvid=0   需引入url模块</description>
    </item>
    
    <item>
      <title>Think in WEB</title>
      <link>https://liudx1985.gitee.io/post/web-start/</link>
      <pubDate>Sat, 20 Nov 2021 16:23:51 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/web-start/</guid>
      <description>§0 HTML、CSS基础参考：    Web 开发技术 | MDN (mozilla.org)
  墙裂推荐：6张思维导图，帮你搞定html、css（css画QQ企鹅） - 简书 (jianshu.com)
      基本概念     常用HTML标签     常用CSS属性     表格和表单     浮动和定位     CSS3     §1 HTTP status code    状态码 状态码英文名称 中文描述     100 Continue 继续。客户端应继续其请求   101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议   200 OK 请求成功。一般用于GET与POST请求   201 Created 已创建。成功请求并创建了新的资源   202 Accepted 已接受。已经接受请求，但未处理完成   203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本   204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档   205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域   206 Partial Content 部分内容。服务器成功处理了部分GET请求   300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择   301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替   302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI   303 See Other 查看其它地址。与301类似。使用GET和POST请求查看   304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源   305 Use Proxy 使用代理。所请求的资源必须通过代理访问   306 Unused 已经被废弃的HTTP状态码   307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向   400 Bad Request 客户端请求的语法错误，服务器无法理解   401 Unauthorized 请求要求用户的身份认证   402 Payment Required 保留，将来使用   403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求   404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&amp;quot;您所请求的资源无法找到&amp;quot;的个性页面   405 Method Not Allowed 客户端请求中的方法被禁止   406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求   407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权   408 Request Time-out 服务器等待客户端发送的请求时间过长，超时   409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突   410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置   411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息   412 Precondition Failed 客户端请求信息的先决条件错误   413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息   414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理   415 Unsupported Media Type 服务器无法处理请求附带的媒体格式   416 Requested range not satisfiable 客户端请求的范围无效   417 Expectation Failed 服务器无法满足Expect的请求头信息   500 Internal Server Error 服务器内部错误，无法完成请求   501 Not Implemented 服务器不支持请求的功能，无法完成请求   502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中   504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求   505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理    §2 CSS Colors CSS 的颜色写法有color keywords|RGB|HSL - CSS color_value | MDN (mozilla.</description>
    </item>
    
    <item>
      <title>excel常用的函数</title>
      <link>https://liudx1985.gitee.io/post/exclel%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 15 Nov 2021 11:43:51 +0800</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/exclel%E5%87%BD%E6%95%B0/</guid>
      <description>Excel函数 入门 $1 单元格和引用 ​	EXCEL表的每个单元格都有两个索引：
 行号，以数字标记，从1开始 列号，以字母标记，如A\B\C&amp;hellip;（大小写不区分）  ​	单元格的引用有如下几种方式：
 同sheet（工作表）  中单元格可以用A1表示相对列（第一列第一行），还有一种方式是$a$1,表示绝对列和行 一列数据 A；一列某几行A1:A7；若干列A:D 一行数据$10:$10,如=SUM($1:$1)可以求出第一行所有值的和。 单元格区域 A1:B2   同一工作簿中不同工作表上的单元格引用  用sheet1!A1表示工作表sheet1的第一列第一行。   不同工作簿中的单元格引用  如果工作簿已打开,例：[会计报表.xls]!工资表!A1  如果工作簿已关闭：D:\工作目录\[会计报表.xls]工资表&#39;!A1。其中“会计报表.xls”是工作簿名称，“工资表”为该工作簿中的工作表名称。“D:\工作目录\”为“会计报表.xls”这个工作簿的文件路径。    ​	绝对引用$A$1和相对引用A1：相对引用在复制单元格时会自动更新值，但绝对引用不会。两种方式可以混用。
$2 关于公式 ​	公式是工作表中进行数值计算的等式。公式键入是以=开始的。简单的公式有加、减、乘、除等计算。例如　=3*6-2 、=A2+B16 、=C4/A6 &amp;hellip;&amp;hellip;
​	复杂一些的公式可能包含函数 、引用、运算符 (有数学、比较、逻辑和引用运算符等）和常量 （不进行计算的值，因此也不会发生变化）。
1. ROW / COLUMN函数 这两个函数返回引用的行号和列号，如 =ROW($A$1)返回1如 =COLUMN($B$2)返回2(注意不是B)
2. IF函数  函数定义：根据条件满足与否返回不同的值
使用格式：IF(logical_test,value_if_true,value_if_false)
白话：IF(条件,与条件一样时运算这个,与条件不同时运算这个)
 如 IF(AND(C1&amp;gt;80,D1&amp;gt;80),&amp;quot;优&amp;quot;, &amp;quot;不及格&amp;quot;)，表示C1和D1均大于80时显示优，否则是不及格。
3. INDEX ​	返回表或区域中的值或值的引用。函数INDEX()有两种形式：数组形式通常返回数值或数值数组；引用形式通常返回引用。	INDEX(array,Row_num,column_num) 返回数组中指定单元格或单元格数组的数值。 如=INDEX(A1:A6,1,1) 返回一个引用，是A1:A6这个区域数组的第一行第一列。</description>
    </item>
    
    <item>
      <title>Vue3 学习大纲</title>
      <link>https://liudx1985.gitee.io/post/vuejs/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/vuejs/</guid>
      <description>[TOC]
1. 前端工程(Big Front End)   浏览器工作原理，HTML、CSS、JavaScript(ES6)
 Web 开发技术 | MDN (mozilla.org) 菜鸟教程 - (runoob.com) ES6 入门教程 - ECMAScript 6入门 (ruanyifeng.com) W3Schools How TO - 实用的代码片段@HTML, CSS and JavaScript    数据-视图分离：MVC、MVVM
 Vue.js (vuejs.org)    前端工程化：(npm、webpack)，组件技术，etc.
 Vue3 教程 | 菜鸟教程 (runoob.com) 、VUE3 教程_w3cschool 指南 | webpack 中文网 (webpackjs.com) GitHub - su37josephxia/vue3-study: vue3学习的各种实验代码 前端面试指南之Vue面试题总结 - 掘金 (juejin.cn) vue3正式发布两年后，我才开始学—vue3+setup+ts（万字总结） - 掘金 (juejin.cn)    工具资源：</description>
    </item>
    
    <item>
      <title>需求分析</title>
      <link>https://liudx1985.gitee.io/post/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 11 May 2021 09:00:49 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</guid>
      <description>1. 定义 ​	将用户非形式的需求表述转化为完整的需求定义，从而确定系统必须做什么的过程。
注意区分用户提出的问题是原始需求(用户需求)，会存在冲突或缺乏可行性的需求，经过需求分析后，形成为&amp;lt;&amp;lt;需求规格说明书&amp;gt;&amp;gt;,需求各组成部分的形成过程见下图1-1  如何收集用户需求可参考相关文档等。
 2. 需求分析过程 graph LRREG[问题识别] --&amp;gt; ANY[细化\分析] --&amp;gt; DOC[需求规格说明书] --&amp;gt; JUDGE[评审] 2.1 问题识别 ​	明确功能需求(做什么)、性能需求(要达到什么指标)、环境需求(如机型、操作系统等)、可靠性需求(不发生故障的概率）、安全保密需求、用户界面需求、资源使用需求(软件运行是所需的内存、CPU等)、软件成本消耗与开发进度需求、预先估计以后系统可能达到的目标。 ​	可归纳为：确定业务规则、功能需求、非功能需求、质量属性(五可六性)、系统约束(时间、预算、技术、人员、组织等)；确立各需求优先级；输出物为部分SRS内容(如需求清单等) ​
2.2 需求分析1 ​	整体的系统分析主要借助{业务流程图},进行需求细化时用到的主要方法有:
  功能分解方法：功能分解——功能、子功能、功能接口。
  结构化分析方法 ：使用数据流图和数据词典
  信息建模方法：常用于数据库管理系统，实体和关系图(ER图)为主要工具
  面向对象的分析方法 : 使用用例图(User case)、类图、时序图等工具
  2.3 编制需求规格说明书(SRS) ​	输出需求分析阶段性成果。详见第3部分
2.4 评审/验证SRS ​	对功能需求的正确性（一致性），完整性和清晰性，以及其它需求给予评价（此部分略）。
3. 编写 SRS 1). 确认角色-场景-需求 2). 绘制业务流程图、界面原型图 3). 根据业务流程图编制用例图 4). 编写功能需求项(通常为表格，含功能项、优先级、说明等)、非功能需求部分、风险(可选)等 5). 完成类图、时序图(*存疑，属设计阶段产物)
3.1 绘制业务流程图 exp 1.</description>
    </item>
    
    <item>
      <title>IDEA里使用 maven搭建一个spring工程</title>
      <link>https://liudx1985.gitee.io/post/maven-spring/</link>
      <pubDate>Sun, 11 Apr 2021 09:00:49 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/maven-spring/</guid>
      <description>IDEA里使用 maven 1.1 修改maven国内源 ​	正常安装完IDEA后，maven是自动安装的，由于官方的源比较慢，需要先修改为国内的源(也可使用Maven 仓库 | 菜鸟教程 (runoob.com)的方法)
  复制文件C:\Program Files\JetBrains\IntelliJ IDEA Educational Edition 2021.1\plugins\maven\lib\maven3\conf\settings.xml到C:\Users\&amp;lt;当前用户名&amp;gt;\.m2\settings.xml
  打开新的settings.xml，找到mirrors节点，插入下面的代码（这里是阿里的源，其他国内源可自行baidu），保存
&amp;lt;mirror&amp;gt;  &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt;  &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;  &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt;  &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt; &amp;lt;/mirror&amp;gt;   打开IDEA.修改设置如图,注意那个setting.xml路径就是2的路径，最下面的文件夹是maven用于保存的本地包的位置：
  2 IDEA中使用maven ​	新手可参考Maven 教程 | 菜鸟教程 (runoob.com)了解maven, 如果你使用过Python的 pip或者node的npm，maven就是java类似对应的工具。不过一般直接用IDEA的插件就可以省去使用maven命令行的麻烦。
  新建一个maven-demo工程：
  完成后在工程根目录下有一个pom.xml文件，这个是POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。参考Maven POM | 菜鸟教程 (runoob.com)
  当我们修改了pom.xml时，如下面新增了junit 4.11的依赖
  &amp;lt;?</description>
    </item>
    
    <item>
      <title>普通话</title>
      <link>https://liudx1985.gitee.io/post/%E6%99%AE%E9%80%9A%E8%AF%9D/</link>
      <pubDate>Sun, 11 Apr 2021 09:00:49 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/%E6%99%AE%E9%80%9A%E8%AF%9D/</guid>
      <description>1&amp;amp;2 普通话发音 1、n、l对比辨音:   n发音时，舌尖抵住上齿龈，软腭下降，打开鼻腔通路，气流振动声带，从鼻腔通过。如：“能耐”、“泥泞”的声母。
  l发音时，舌尖抵住上齿龈，软腭上升，堵塞鼻腔通路，气流振动声带，从舌头两边通过。如“玲珑”、“嘹亮”的声母。
  2、zh ch sh与z c s 第四题 </description>
    </item>
    
    <item>
      <title>Python数据分析简介&amp;环境准备</title>
      <link>https://liudx1985.gitee.io/post/data-analyze/</link>
      <pubDate>Tue, 30 Mar 2021 15:11:49 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/data-analyze/</guid>
      <description>1 概览   数据分析定义：数据分析是指用适当的统计分析方法对收集来的大量数据进行分析，提取有用信息和形成结论而对数据加以详细研究和概括总结的过程。
  思维导图
  数据分析完整流程：
start=&amp;gt;start: 明确分析目的fetch=&amp;gt;operation: 数据获取pre_oper=&amp;gt;operation: 数据预处理(清洗/转换)analyze=&amp;gt;operation: 数据分析show=&amp;gt;operation: 数据展现(报表、图表)report=&amp;gt;end: 决策start(right)-&amp;gt;fetch(right)-&amp;gt;pre_oper-&amp;gt;analyze-&amp;gt;show(right)-&amp;gt;report   主流数据分析语言:python以及相关的数据分析库[numpy]、pandas等。
  相关领域：数据挖掘、深度学习（机器学习)、人工智能等
  职业发展：算法工程师、数据分析员(师)、数据产品经理、ETL工程师、数据挖掘工程师；数据科学家等
  准备工作 ​	课程使用anaconda作为实验环境。Anaconda是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。先下载Anaconda安装包。推荐跟随Anaconda下载页面的Windows安装指导,;确认设置是否正确方法：打开命令行窗口（cmd.exe），输入python以打开Python解释器。可以看到类似下面的Anaconda版本的输出：
C:\Users\wesm&amp;gt;python Python 3.5.2 |Anaconda 4.1.1 (64-bit)| (default, Jul 5 2016, 11:41:13) [MSC v.1900 64 bit (AMD64)] on win32 &amp;gt;&amp;gt;&amp;gt; 要退出shell，按Ctrl-D（Linux或macOS上），Ctrl-Z（Windows上），或输入命令exit()，再按Enter。
​	我们主要使用jupyter-notebook编写代码。
jupyter notebook起始目录修改方法
 打开anaconda SHELL，输入命令jupyter notebook --generate-config，将生成 jupyter_notebook_config.py文件 打开上一步生成的文件:C:\Users\liudx\.jupyter\jupyter_notebook_config.py,找到c.NotebookApp.notebook_dir 前面的“#”符号（#表示注释的意思）,修改为起始目录 **重启jupyter notebook **  3 resources 1.</description>
    </item>
    
    <item>
      <title>fibnocci</title>
      <link>https://liudx1985.gitee.io/post/fibnocci/</link>
      <pubDate>Sat, 30 Jan 2021 15:11:49 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/fibnocci/</guid>
      <description>0 Fibonacci定义 ​	&amp;gt; $ f(n+1)=f(n)+f(n-1),\space n &amp;gt;= 1$
1. $\sum(f(n)^2) = f(n)\cdot f(n+1)$ ​	面积之和相等:
证明aka.绘图代码如下
import matplotlib.pyplot as plt from matplotlib.path import Path import matplotlib.patches as patches import numpy as np  def fib(max): 	a, b = 1, 1; 	while a &amp;lt; max: 	yield a; 	a, b = b, a + b; 	verts = [  ] codes = [ # Path.MOVETO, # Path.</description>
    </item>
    
    <item>
      <title>Latex公式</title>
      <link>https://liudx1985.gitee.io/post/latex/</link>
      <pubDate>Sat, 30 Jan 2021 15:11:49 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/latex/</guid>
      <description>$\LaTeX$ Symbol   $$ z = r\cdot e^{2\pi i} \quad \sqrt{x} \quad \frac{1}{2} $$ $$z = r\cdot e^{2\pi i} \quad \sqrt{x} \quad \frac{1}{2} $$
  $$ \pm \quad \times \quad \div \quad \cdot \quad \cap \quad \cup \quad $$ $$ &amp;gt; \quad&amp;lt; \quad\geq \quad \leq \quad \neq \quad \approx \quad \equiv $$ $$ \pm \quad \times \quad \div \quad \cdot \quad \cap \quad \cup \\ \quad&amp;gt; \quad&amp;lt; \quad\geq \quad \leq \quad \neq \quad \approx \quad \equiv $$</description>
    </item>
    
    <item>
      <title>MPI实践</title>
      <link>https://liudx1985.gitee.io/post/mpi/</link>
      <pubDate>Sat, 30 Jan 2021 15:11:49 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/mpi/</guid>
      <description>1. setup mpich2 mpiexec -remove to remove account for each computer node mpiexec -register to add account for each computer &amp;#39;node&amp;#39; mpiexec -validate to validate the account Notice ,you must create a account(username/password all same) for all nodes on windows.
2. build boost.mpi 修改boost_1_47_0\tools\build\v2\tools\mpi.jam文件，修改的地方如下：
 #local cluster_pack_path_native = &amp;#34;C:\\Program Files\\Microsoft Compute Cluster Pack&amp;#34; ;local cluster_pack_path_native = &amp;#34;D:\\Program Files\\MPICH2&amp;#34; ; ...options = &amp;lt;include&amp;gt;$(cluster_pack_path)/Include &amp;lt;address-model&amp;gt;64:&amp;lt;library-path&amp;gt;$(cluster_pack_path)/Lib/amd64&amp;lt;library-path&amp;gt;$(cluster_pack_path)/Lib&amp;lt;find-static-library&amp;gt;mpich2d&amp;lt;toolset&amp;gt;msvc:&amp;lt;define&amp;gt;_SECURE_SCL=0 找到 需要在boost_1_47_0\tools\build\v2\user-config.jam中加入（注意空格！！！）</description>
    </item>
    
    <item>
      <title>最小二乘法</title>
      <link>https://liudx1985.gitee.io/post/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%95%B0%E4%B9%98%E6%B3%95/</link>
      <pubDate>Thu, 30 Apr 2020 20:30:00 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%95%B0%E4%B9%98%E6%B3%95/</guid>
      <description>Optimize Program 最小二乘法 OLS (https://zhuanlan.zhihu.com/p/38128785)  Define 1.要求函数$f$ 在$g$ 约束下的极值这种问题 $$ minmax\quad f(x)\ s.t.(subject\space to)\space g_i(x)=0 $$
拉格朗日数乘法求极值 Example 1 $已知x&amp;gt;0,y&amp;gt;0, x+2y+2xy = 8, 求x+2y最小值$
等同于求$L(x) = x+2y+\lambda(x+2y+2xy-8)$的最小值(无论$\lambda$取何值，后面部分都是0)，由极值条件有：
$$ \begin{cases} L&amp;rsquo;_x=1+λ+2λ y = 0 \\ L&amp;rsquo;_y=2+2λ +2λ x = 0 \\ L&amp;rsquo;_λ= x+2y+2xy-8 = 0 \end{cases} \Rightarrow \begin{cases} x=2\\ y=1 \end{cases}\\ \therefore min(L(x)) = 4 $$</description>
    </item>
    
    <item>
      <title>Think in geometry (part I)</title>
      <link>https://liudx1985.gitee.io/post/geometry01/</link>
      <pubDate>Tue, 02 Jul 2019 15:11:49 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/geometry01/</guid>
      <description>1. Geometry ​	几何学源自古代农业生产活动中发展的测量土地技术，欧几里得的《几何原本》是古典几何的集大成。中国古代很早就发现了勾股定理、掌握了割圆术等一系列几何学知识，可惜受制于封建统治阶级的意思形态，科学技术对没有对社会生产力产生直接的推动，近现代几何学一直为西方主导。随着数学三大基础方向的发展，代数学和几何学的融合，导致解析几何的产生，分析学在几何方向催生出曲面几何、拓扑学等。几何学自身也在蓬勃发展，在欧氏几何上发展出非欧几何（黎曼几何）、微分几何、分形等科学分支。本文主要记录一些笔者在解析几何的思考。
2 Line in 2d ​	初中我们就学过平面的直线方程：
$$ y = kx+b\quad\quad (1) $$
​	老师会告诉我们这个公式(1)斜率是$k$，$b$是$y$轴偏移，但是很不幸的是，这个方程并不能表示所有的平面直线，像$x=1$这类与$x$轴平行的直线是没有办法写成(1)的，因为斜率不能为&amp;rsquo;$\infty $&amp;rsquo;!。所以在计算两点$A(x_1,y_1),B(x_1,y_1)$构成的直线时，我们需要分情况判断： $$ \begin{cases} x=x_1,\quad x_1=x_2 \\ y=\dfrac{y_1-y_2}{x_1-x_2}x+\dfrac{x_1y_2-x_2y_1}{x_1-x_2},\quad x_1\ne x_2 \end{cases} $$ ​	那么，有没有高级的方程，可以不用搞这么麻烦呢？答案是有的，高中老师告诉我们，直线有一般方程，可以统一描述所有直线： $$ ax+by+c = 0\quad\quad (2) $$ ​	这个方程倒是解决了上述问题，但是初次接触是不如（1）式直观，参数$a、b、c$在当时看来没有几何意义的，对比（1）里面的斜率和截距$k、b$就很直观，而且参数还多了一个。一般方程的几何意义在学习了向量之后才会比较明确，我们先回忆下向量相关的基础知识，向量也叫矢量，具有方向，一般第一次接触都是用笛卡尔坐标来描述，就是$x-o-y$轴上的分量来给定向量坐标，大部分高中生都默认这个为向量的定义，但其实向量在代数学中是和向量空间一起定义的，一组向量基构成一个向量空间，而向量是这些基的线性组合，由于向量空间具备封闭性，向量的线性组合仍然位于空间内，直观解释就是，将平面内的任意向量线性相加仍然在平面内，三维的向量$\bar{v}$在基坐标$(1,0,0)、(0,1,0)、(0,0,1)$的线性组合下仍然位于三维空间内，这个线性组合的系数正是向量坐标： $$ \vec{v} = x\cdot(1,0,0)+y\cdot(0,1,0)+z\cdot(0,0,1) $$ ​	向量具备一些基本性质，如线性性、交换性等，这些都是向量空间的基本性质，只不过限于初次接触时知识不够，没有办法了解，到后面学习了高等代数和向量空间，这些都是自然而然的结论。向量有两种重要的运算，即内积和外积，向量内积的定义为： $$ \vec{a}\cdot \vec{b} = |a|\cdot |b|cos&amp;lt;a,b&amp;gt;\quad \quad (3) $$ ​	内积是一个标量，其大小等于两个向量的长度积乘两向量夹角的余弦。向量长度定义为$\sqrt{x^2+y^2}$，几何意义就是距离坐标原点的距离（由勾股定理得）。内积也可以写成: $$ (a,b)\cdot(c,d) = ac+bd	\quad\quad (4) $$ ​	（3）和（4）是如何等价的？这个也困扰了我很久，直到我知道了欧拉公式： $$ e^{ix}=cosx+isinx \quad\quad (5) $$ ​	将$\vec{a}\cdot \vec{b}$写成$\vec{a}=r_1(\cos \alpha ,\sin \alpha)=r_1e^{i\alpha},\vec{b}=r_2(\cos \beta,\sin \beta)=r_2e^{i\beta}$，内积可以写成： $$ \vec{a}\cdot \vec{b} = r_1\cdot r_2\cdot e^{i(\alpha-\beta)} = r_1 cos\alpha \cdot r_2 cos\beta + r_1 sin\alpha \cdot r_2 sin\beta + i r_1 r_2sin(\alpha-\beta)\quad\quad (6) $$ ​	上式中的实数部分(位于平面内)正好就是$ac+bd$，虚数部分的含义有点迷，暂时也不用管了（这个是外积部分，在平面外）。</description>
    </item>
    
    <item>
      <title>category</title>
      <link>https://liudx1985.gitee.io/post/category/</link>
      <pubDate>Tue, 25 Jun 2019 10:20:32 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/category/</guid>
      <description>群论、范畴论入门  众所周知，数学的三大方向分别是代数、几何、分析，数相关的归于代数，如初等代数、数论、抽象代数-群论等；几何研究空间和形状，如解析几何、欧氏几何、非欧几何（黎曼几何）、拓扑学、微分几何(流形)等；分析则是数和形之间的纽带，主要包括微积分、实分析、复分析、泛函分析，以及在此基础上发展出的常微分、复变函数与积分变换等。另外概率论-统计、逻辑学、离散数学都可看做三大方向的复合学科。现代数学抽象化程度更高，为了将集合论、群论、向量空间与拓扑中有很多相似的概念统一地表示出来，发展出一门新的学科即范畴论(Category） 。
1 群的基本概念1  群定义为满足如下条件的封闭集合G：
 定义一种二元代数运算$\forall a \in G, \exists f:a\mapsto b,b \in G$ 运算满足结合律:$f:a\mapsto b，g:b\mapsto c， f\circ g：a\mapsto c$ 存在单位元：$\exists e, f(e)= e$ 存在逆元：$\forall a \in G, f(a)=b,\exists f^{-1}(b)=a$   当集合满足1、2时，称为半群，满足1、2、3时称为幺半群(单位半群，$\frac{3}{4}$群)；如果1,2,3,4再附加一个交换律$ f\circ g= g\circ f$则称为Abel交换群。常见有的整数加法群(Z,0,+)、实数乘法群(Q,1,*)，以及S2(平面旋转群等)。整数加群是一个Abel交换群。
2 偏序关系  偏序关系（partial order relation）的定义是集合P 与一个二元关系运算&amp;rsquo;$\le$&amp;lsquo;定义的，这个二元关系需要满足：
 自反性：$x\le x$ 反对称性：$x \le y 且y \le x \Rightarrow x = y$ 传递性：$x \le y 且y \le z \Rightarrow x \le z$   那么集合P 中的每个元素都可以对应一个范畴上的对象，$\le$ 对应态射，首先就满足了 范畴上每个对象都有id 映射，由于这个关系是可以传递的，所以它是可复合的，例如$f$ 为 $x \le y$，$g$ 为$y\le z$，那么$f \circ g$ 就得到了 $x\le z$，当然这种复合也是可结合的。</description>
    </item>
    
    <item>
      <title>gcc gdb</title>
      <link>https://liudx1985.gitee.io/post/gnu/</link>
      <pubDate>Tue, 30 Apr 2019 20:30:00 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/gnu/</guid>
      <description>1、GNU Assoc 1.1 GCC options std c++lib
$ g++ -O2 -Wall -Wextra -pthread -I./include -std=C++11 prog.cc
1.2 GDB usage Start  https://www.ibm.com/developerworks/cn/linux/sdk/gdb/index.html
 gcc option: -g
gcc -g a.c -o a
**mount to remote server ** mount -t nfs -o nolock 10.82.20.97:/home/crash /tmp/crash
gdb start:
gdb exe [pid|-c core-dump-file]
basical command  run ; start prog break 22 ; create a breakpoint at line 21 next ; step next line continue ; go exec print val ; display variable &amp;lsquo;val&amp;rsquo; info break ; display all break bt ; backtrace: display stack frames frame 1 ; switch to frame 1{current frame 0} set val=1 ; set variable &amp;lsquo;val&amp;rsquo; to 1 quit ; exit gdb  </description>
    </item>
    
    <item>
      <title>python绘制参数方程的动画</title>
      <link>https://liudx1985.gitee.io/post/py-animation/</link>
      <pubDate>Mon, 29 Apr 2019 16:22:50 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/py-animation/</guid>
      <description>© 2018 *All rights reserved by liudx .:smile:
​	Python的matplotlib是一个功能强大的绘图库，可以很方便的绘制数学图形。官方给出了很多简单的实例，结合中文翻译的示例Tutorial，可以满足日常工作的大部分需求了。但是实际工作中，一些有趣的东西很难使用常规方程（笛卡尔坐标和极坐标）方式绘制，事实上，大部分工程上都是使用参数方程来描述曲线。本文给出一些参数方程绘制的实例，之后会扩展为动画形式绘制，可以看到这些复杂的方程是如何简单优美的绘制出来。
1 参数方程绘制 ​	首先介绍下椭圆的参数方程：
$$ \begin{cases} x = a \cdot \cos(t)\\ y = b \cdot \sin(t) \end{cases} $$
​	其中$a,b$分别是椭圆的长轴、短轴。绘制椭圆的python代码如下:
import matplotlib.pyplot as plt import numpy as np  fig = plt.figure() ax = plt.gca() #椭圆参数方程 r1 = 1.1 r2 = 1 t = np.linspace(0, np.pi*2, 1000) # 生成参数t的数组 x = r1 * np.cos(t) y = r2 * np.sin(t) plt.plot(x, y, color=&amp;#39;blue&amp;#39;, linewidth=2, label=&amp;#39;ellipse&amp;#39;) plt.</description>
    </item>
    
    <item>
      <title>同余和整除判定</title>
      <link>https://liudx1985.gitee.io/post/modulo/</link>
      <pubDate>Mon, 08 Apr 2019 10:40:01 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/modulo/</guid>
      <description>1. 同余(congruence modulo) ​	同余是指两个整数a、b，若它们除以整数m所得的余数相等，则称a与b对于模m同余或a同余于b模m。同余的符号是$\equiv$。常用的记法是 $$ a\equiv c\space mod(n) $$ ​	一般默认$n$为非零整数，$a、c$为非负整数，当然，对于所有的整数，同余的定义和相关性质都是成立的。 $$ 10\equiv 3\space mod\space 7\\ 1\equiv 10\space mod\space 3 $$
2.同余的性质及证明方法 ​	同余基本性质有反身性，对称性，传递性和线性可加性,分别如下: $$ a\equiv a\space mod(n) \\ a\equiv b\space mod(n) \Leftrightarrow b\equiv a\space mod(n) \\ a\equiv b\space mod(n)，b\equiv c\space mod(n) \Rightarrow b\equiv c\space mod(n) \\ a\equiv b\space mod(n)，c\equiv d\space mod(n) \Rightarrow a\pm c\equiv b\pm d\space mod(n) \\ a\equiv b\space mod(n)，c\equiv d\space mod(n) \Rightarrow ac\equiv bd\space mod(n) $$</description>
    </item>
    
    <item>
      <title>python 迭代器和惰性计算、函数式编程基础</title>
      <link>https://liudx1985.gitee.io/post/py-lazy/</link>
      <pubDate>Tue, 19 Mar 2019 17:02:29 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/py-lazy/</guid>
      <description>​	本文介绍了python 的生成器，构造一些有趣的惰性计算程序，可以作为python函数式的基础。
1. iterator and generator ​	众所周知，python3里面的range返回是一个对象而不是列表，它的前身是python 2的xrange。python 2里面的range会生成一个列表，当这个列表很大时，会有严重的性能问题:
for x in range(0,100000):  print(x) ​	可以使用iter(range(0,100000))将range对象转换为可迭代实例（iterator），下面的代码是和上面代码等价的：
lst=iter(range(0,10)) while True:  try:  b = next(lst) # 调用lst.__next__()  print(b)  except StopIteration:  break ​	显而易见，其实python的for循环其实是个语法糖，首先隐式将list（可迭代对象）转换为list_iterator，然后不断调用迭代器的__next__函数，直到出现StopIteration为止；下面是一个迭代器的实例（注意内部函数__next__）：
class fibonacci:  &amp;#39;&amp;#39;&amp;#39;To use this class like this for n in fibonacci(100): print(n, end=&amp;#39;,&amp;#39;) &amp;#39;&amp;#39;&amp;#39;  def __init__(self, max):  self.max = max   #可迭代对象实现了__iter__方法，str、list、set、dict、file、sockets等容器都有这个内部函数  def __iter__(self):  self.</description>
    </item>
    
    <item>
      <title>fold and unfold</title>
      <link>https://liudx1985.gitee.io/post/fold-and-unfold/</link>
      <pubDate>Wed, 16 Jan 2019 14:14:33 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/fold-and-unfold/</guid>
      <description>​	Haskell里面有两个著名的fold函数:foldr/foldl，这两个函数非常具有函数式编程的特点(递归)，几户所有的Haskell教程都会使用foldr/foldl来完成一些命令式语言的循环语句。还有个更少见的unfoldr函数,可以完成一些匪夷所思的操作。
1 fold ​	几乎所有的函数式语言都有类似的函数，如Javascript的对应是reduce1reduceRight();Haskell的fold有两个版本，分别是foldr和foldl，两个函数主要区别在后缀上，一个从右折叠，一个从左折叠，位于Data.List,常见的教程里面定义的简单版本如下：
foldr :: (a -&amp;gt; b -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; b foldr step zero (x:xs) = step x (foldr step zero xs) foldr _ zero [] = zero  foldl :: (a -&amp;gt; b -&amp;gt; a) -&amp;gt; a -&amp;gt; [b] -&amp;gt; a foldl step zero (x:xs) = foldl step (step zero x) xs foldl _ zero [] = zero ​	fold的参数依次为step函数、初始值、列表，返回值为一个和初始值类型一样的值。注意foldr和foldl的step函数都是二元函数，foldr的step参数顺序为列表元素、折叠变量,foldl的刚好反过来！这点很容易搞混淆。一般我们直接使用预定义的就行，当然对于Data.Tree等可折叠的类型，foldr/foldl也可以适用，方法类似。
​	众所周知，Haskell构造列表只能向头部插入元素：1:[2,3],连接链表也可以使用concat函数或者++：[1.</description>
    </item>
    
    <item>
      <title>Dynamic Programming</title>
      <link>https://liudx1985.gitee.io/post/dynamic-programming/</link>
      <pubDate>Tue, 15 Jan 2019 15:10:09 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/dynamic-programming/</guid>
      <description>​	Dynamic programming is a math method for some special problems1,for any $n$ ,the problem can be reduce to sub problems recursively.the Fibonacci is a typical DP problem:
 $$ fib(n) = fib(n-1) + fib(n-2) $$
 ​	For a positive integer $n$ the result $fib(n)$ can be parted into two sub problems $fib(n-1)$ and $fib(n-2)$; for $n=0,1$ the result is 1 :
fib n  | (n == 0) = a  | (n == 1) = b  | otherwise = fib (n - 1) + fib (n - 2)  where a = 1; b = 1 ​	or a more complex version:</description>
    </item>
    
    <item>
      <title>Start 2019</title>
      <link>https://liudx1985.gitee.io/post/hello-world/</link>
      <pubDate>Fri, 11 Jan 2019 11:12:34 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/post/hello-world/</guid>
      <description>© 2018 *All rights reserved by liudx .:smile: *
==No body can live without H~2~0 and knowledge==
1 Tools  MicroSoft® VScode用来写前端代码，推荐安装插件：Dracula Offical（主题）、Beautify、Auto Rename Tag、Bracket Pair Colorizer 2、Open in Brower、Vetur listary和everything一样，是一个强大的windows快速本地搜索工具 天若OCR是一个OCR工具 Windows剪贴工具Ditto ripgrep是windows下的grep命令行工具,使用方法:rg textor rg --maxdepth 1 text  2 Python Python:第三方库：scipy,matplotlib,fabric(remote batch),requests(network)
  pip upgrade: $Python\Scripts\easy_install.exe pip==8.1.2 ,修改国内源：新建文件C:\Users\Admin\pip\pip.ini:
[global] index-url = http://mirrors.aliyun.com/pypi/simple   Jupyter notebook:用于交互式编写python脚本,支持markdown语法，安装方法
 $pip install jupyter -i https://pypi.tuna.tsinghua.edu.cn/simple;
   jupyter notebook 起始目录修改方法：</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://liudx1985.gitee.io/about/</link>
      <pubDate>Wed, 12 Dec 2012 12:12:12 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/about/</guid>
      <description>mail：375567923@QQ.com
Gitee: 尘埃落定 (liudx1985) - Gitee.com
 工作经历：  2004/09-2008/07： 就读于武汉理工大学-信息与计算科学专业，获得本科学位 2008/8-2010/3：任职于武汉适普软件有限公司 从事软件研发 2010/5- 2019/8：任职于烽火通信科技股份有限公司 ，从事网络管理系统研发，担任工程师、高级工程师 2014/09-2017/05 ：就读于华中科技大学，获取软件工程-硕士学位 2019/10-今：在武汉职业技术学院-计算机技术与软件工程学院) 任教  爱好： 单车、羽毛球、游泳、基努·里维斯脑残粉</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://liudx1985.gitee.io/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liudx1985.gitee.io/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
